const {
  SlashCommandBuilder,
  AttachmentBuilder,
  EmbedBuilder,
} = require("discord.js");
const { Client, Workflow } = require("@stable-canvas/comfyui-client");
const WebSocket = require("ws");
const { fetch } = import("node-fetch");
const path = require("path");
const fs = require("fs");

const directory = process.env.OUTPUT_DIR;

module.exports = {
  data: new SlashCommandBuilder()
    .setName("image")
    .setDescription("Have the bot generate image based on your prompt")
    .addStringOption((option) =>
      option
        .setName("prompt")
        .setDescription("The prompt you want to send to the bot")
        .setRequired(true)
    ),
  async execute(interaction) {
    await interaction.deferReply();
    const createWorkflow = () => {
      const workflow = new Workflow();
      const cls = workflow.classes;

      /*Load VAE*/
      const [VAE_1] = cls.VAELoader({
        vae_name: "ae.safetensors",
      });
      /*KSamplerSelect*/
      const [SAMPLER_1] = cls.KSamplerSelect({
        sampler_name: "euler",
      });
      /*RandomNoise*/
      const [NOISE_1] = cls.RandomNoise({
        noise_seed: Math.floor(Math.random() * 2 ** 32),
      });
      /*Height*/
      const [OUT_0_2] = cls.PrimitiveInt({
        value: 1024,
      });
      /*Width*/
      const [OUT_0_1] = cls.PrimitiveInt({
        value: 1024,
      });
      /*EmptySD3LatentImage*/
      const [LATENT_3] = cls.EmptySD3LatentImage({
        width: OUT_0_1,
        height: OUT_0_2,
        batch_size: 1,
      });
      /*Load Diffusion Model*/
      const [MODEL_1] = cls.UNETLoader({
        unet_name: "flux_dev.safetensors",
        weight_dtype: "fp8_e4m3fn_fast",
      });
      /*ModelSamplingFlux*/
      const [MODEL_2] = cls.ModelSamplingFlux({
        max_shift: 1.15,
        base_shift: 0.5,
        width: OUT_0_1,
        height: OUT_0_2,
        model: MODEL_1,
      });
      /*BasicScheduler*/
      const [SIGMAS_1] = cls.BasicScheduler({
        scheduler: "beta",
        steps: 20,
        denoise: 1,
        model: MODEL_2,
      });
      /*DualCLIPLoader*/
      const [CLIP_1] = cls.DualCLIPLoader({
        clip_name1: "t5xxl_fp16.safetensors",
        clip_name2: "clip_l.safetensors",
        type: "flux",
        device: "default",
      });
      /*CLIP Text Encode (Prompt)*/
      const [CONDITIONING_1] = cls.CLIPTextEncode({
        text: interaction.options.getString("prompt"),
        clip: CLIP_1,
      });
      /*FluxGuidance*/
      const [CONDITIONING_2] = cls.FluxGuidance({
        guidance: 3.5,
        conditioning: CONDITIONING_1,
      });
      /*BasicGuider*/
      const [GUIDER_1] = cls.BasicGuider({
        model: MODEL_2,
        conditioning: CONDITIONING_2,
      });
      /*SamplerCustomAdvanced*/
      const [LATENT_1, LATENT_2] = cls.SamplerCustomAdvanced({
        noise: NOISE_1,
        guider: GUIDER_1,
        sampler: SAMPLER_1,
        sigmas: SIGMAS_1,
        latent_image: LATENT_3,
      });
      /*VAE Decode*/
      const [IMAGE_1] = cls.VAEDecode({
        samples: LATENT_1,
        vae: VAE_1,
      });
      /*Save Image*/
      const [] = cls.SaveImage({
        filename_prefix: "Comfy",
        images: IMAGE_1,
      });

      return workflow;
    };

    const client = new Client({
      api_host: "127.0.0.1:8188",
      WebSocket,
      fetch,
    });

    await client.connect();

    const workflow = createWorkflow();
    let url = "";
    console.time("enqueue workflow");
    try {
      let data = await workflow.invoke(client);
      console.log(data);
      url = data.images[0].data;
    } catch (error) {
      throw error;
    } finally {
      console.timeEnd("enqueue workflow");
      client.disconnect();
    }

    const attachment = new AttachmentBuilder(url, { name: "img.jpg" });

    const exampleEmbed = new EmbedBuilder()
      .setTitle("Generated by Goose AI!")
      .setDescription("Prompt: " + interaction.options.getString("prompt"))
      .setImage("attachment://img.jpg");
    await interaction.editReply({
      embeds: [exampleEmbed],
      files: [attachment],
    });

    if (directory !== undefined || directory !== "") {
      fs.readdir(directory, (err, files) => {
        if (err) throw err;
        for (const file of files) {
          fs.unlink(path.join(directory, file), (err) => {
            if (err) throw err;
          });
        }
      });
    }
  },
};
